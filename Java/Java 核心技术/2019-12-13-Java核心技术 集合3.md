---
layout:  post
title:   Java核心技术 集合3
date:   2019-12-13 19:36:40
author:  'zhangtao'
header-img: 'img/post-bg-2015.jpg'
catalog:   false
tags:
-Java核心技术

---



## 4.视图与包装器

使用_视图（views）_可以获得其他的实现了Collection接口和Map接口的对象。 映射类的keySet方法就是一个这样的示例。keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射进行操作。这种集合称为视图。

### 轻量级集合包装器

Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器。这个方法可以将数组传递给一个期望得到列表或集合参数的方法：

```java
Card[] cards = new Card[52];
List<Card> cardList = Arrays.asList(cards);
```

返回的对象不是ArrayList,是一个视图对象，带有访问底层数组的get和set方法。改变数组大小的所有方法都会抛出一个UnsupportedOperationException异常。 asList方法可以接收可变数目的参数：

```java
List<String> names = Arrays.asList("Amy", "Bob", "Carl");
List<String> nameList = Collections.nCopies(10, "Mack");
System.out.println(names);
System.out.println(nameList);
// [Amy, Bob, Carl]
// [Mack, Mack, Mack, Mack, Mack, Mack, Mack, Mack, Mack, Mack]
```

Collections.nCopies(n, anObject)返回一个实现了List接口的不可修改的对象，并给人一种包含n个元素，每个元素都像是anObject的错觉。且存储代价很小，这是视图技术的一种巧妙应用。

Collections.singleton(anObject)返回一个实现了Set接口的视图对象，是一个不可修改的单元素集，不需要付出建立数据结构的开销。singletonList与singletonMap方法类似。 集合框架的每一个接口，还有一些方法可以生成空集、列表、映射等。特别是集的类型可以推导得出：

```java
Set<String> deepThoughts = Collections.emptySet();
```

### 子范围

可以为很多集合建立子范围（subrance）视图。

```java
List group2 = staff.subList(10, 20); //取出第10~19个元素获得一个列表的子范围视图
```

第一个索引包含在内，第二个则不包含。可以将任何操作应用于子范围，并且能够自动地反应整个列表的情况。

```java
List<String> names = new ArrayList<>();
names.add("Amy");
names.add("Bob");
names.add("Yoyo");
names.add("Claire");
names.add("Carl");
List group = names.subList(2, 4);
group.add("Haha");
System.out.println(names);
System.out.println(group);
group.clear();
System.out.println(names);
System.out.println(group);
// [Amy, Bob, Yoyo, Claire, Haha, Carl]
// [Yoyo, Claire, Haha]
// [Amy, Bob, Carl]
// []
```

group.clear()元素自动从列表中清楚，并且group为空。 对于有序集合映射，可以使用排序顺序而不是元素位置建立子范围，SortedSet接口声明了3个方法： SortedSet&lt; E &gt; subSet(E from, E to) SortedSet&lt; E &gt; headSet(E to) SortedSet&lt; E &gt; tailSet(E from) 这些方法将返回大于等于from且小于to的所有元素子集。 有序映射也有类似的方法： SortedMap&lt; K, V &gt; subMap(K from, K to) SortedMap&lt; K, V &gt; headMap(K to) SortedMap&lt; K , V &gt; tailMap(K from) 返回映射视图， 该映射包含键落在指定范围内的所有元素。 Java SE 6 引人的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包括边界： NavigableSet&lt; E &gt; subSet(E from, boolean fromlnclusive, E to, boolean tolnclusive) NavigableSet&lt; E &gt; headSet(E to, boolean tolnclusive) NavigableSet&lt; E &gt; tailSet(E from, boolean fromlnclusive)

### 不可修改的视图

不可修改视图（unmodifiable views），这些视图对现有集合增加了一个运行时检查，如果发现视图对集合进行修改，就抛出异常，同时这个集合将保持未修改的状态。 Collections. unmodifiableCollection Collections.unmodifiableList Collections.unmodifiableSet Collections.unmodifiableSortedSet Collections.unmodifiableNavigableSet Collections.unmodifiableMap Collections.unmodifiableSortedMap Collections.unmodifiableNavigableMap 每个方法都定义于一个接口。Collections. unmodifiableCollection与ArrayList、LinkedList或者任何实现了List接口的其他类一起协同工作。

```java
List<String> staff = new LinkedList();
1ookAt(Collections.unmodifiableList(staff));
```

Collections.unmodifiableList方法将返回一个实现 List 接口的类对象。其访问器方法将从staff 集合中获取值。当然，lookAt 方法可以调用 List 接口中的所有方法，而不只是访问器。但是所有的更改器方法（例如， add) 已经被重新定义为抛出一个UnsupportedOperationException异常，而不是将调用传递给底层集合。 不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用在这里是 staff)对集合进行修改。并且仍然可以让集合的元素调用更改器方法。 由于视图只是包装了接口而不是实际的集合对象， 所以只能访问接口中定义的方法。例如， LinkedList 类有一些非常方便的方法，addFirst 和 addLast，它们都不是 List 接口的方法，不能通过不可修改视图进行访问。

unmodifiableCollection 方法（与本节稍后讨论的 synchronizedCollection 和 checkedCollection 方法一样）将返回一个集合， 它的 equals 方法不调用底层集合的 equals 方法。相反， 它继承了 Object 类的 equals 方法， 这个方法只是检测两个对象是否是同一个对象。

### 同步视图

Java使用视图机制来确保常规集合的线程安全，而不是实现线程安全的集合类。 例如Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步访问的Map：

```java
Map<String, Employee> map = Collections.synchronizedMap(new HashMap<>());
```

现在可以由多线程访问map对象，即在另一个线程调用另一个方法之前，刚才的方法调用必须彻底完成。

### 受查视图

受查视图用来对泛型类型发生问题时提供调试支持。 实际上将错误类型的元素混入泛型集合中的问题极有可能发生：

```java
ArrayList<String> strings = new ArrayList<>();
ArrayList rawList = strings;
rawList.add(new Date());
```

这个add命令在运行时检查不到，在后面调用get并转化为String时，才会抛出异常。 受查视图可以探测到这类问题：

```java
List<String> safeStrings = Collections.checkedList(strings, String.class);
```

视图的add方法将检测插入对象是否属于给定类。如果不是就抛出ClassCastException。这样做的好处是错误可以在正确的位置得以报告。 受查视图受限于虚拟机可以运行的运行时检查。对于 ArrayList &lt;Pair&lt; String&gt;&gt;, 由于虚拟机有一个单独的“ 原始” Pair 类， 所以，无法阻止插入Pair &lt; Date&gt;。

## 5.算法

泛型集合的一大优点，即算法只需实现一次。 找出数组中最大元素，程序设计人员针对数组列表、链表需要实现不同的实现。但算法都可以直接用迭代器遍历每个元素就可以计算最大元素，因此可以实现能够接收任何实现了Collection接口的max方法：

```java
public static <T extends Comparable> T max(Collection<T> c) {
    if (c.isEmpty()) {
        throw new NoSuchElementException();
    }
    Iterator<T> iterator = c.iterator();
    T largest = iterator.next();
    while (iterator.hasNext()) {
        T next = iterator.next();
        if (largest.compareTo(next) < 0) {
            largest = next;
        }
    }
    return largest;
}
```

Java类库抱哈了基本的排序、二分查找等实用算法。

### 排序与混排

Collections类中的sort方法可以对实现了List接口的集合进行排序：

```java
List<String> staff = new LinkedList<>();
Collections.sort(staff);
```

这个方法假定列表元素实现了Comparable接口。如果箱采用其它方式排序，可以使用List接口的sort方法，并传入一个Comparator对象：

```java
staff.sort(Comparator.comparingDouble(Employee::getSalary));
```

Collections.reverseOrder()返回一个对列表降序排序的比较器，比较器返回b.compareTo(a)。staff.sort(Comparator.reverseOrder())，将根据元素类型的compareTo方法给定排序顺序，按照逆序对列表staff进行排序。 同样，staff.sort(Comparator.comparingDouble(Employee::getSalary).reversed())将按工资逆序排序。

```java
List<String> staff = new ArrayList<>();
staff.add("Mack");
staff.add("Amy");
staff.add("Bobby");
Collections.sort(staff);
System.out.println(staff);
staff.sort(Collections.reverseOrder());
System.out.println(staff);
staff.sort(Comparator.reverseOrder());
System.out.println(staff);
staff.sort(Comparator.comparingInt(String::length).reversed());
System.out.println(staff);
// [Amy, Bobby, Mack]
// [Mack, Bobby, Amy]
// [Mack, Bobby, Amy]
// [Bobby, Mack, Amy]
```

很多书籍中有关排序算法，使用的是随机访问方式。Java对列表进行随机访问的效率很低，实际上可以使用归并排序对列表进行高效排序，然而Java直接将所有元素转入一个数组，对数组进行排序，然后将排序后的序列复制回列表。 集合类库中使用的排序算法比快速排序要慢一下。归并排序有一个主要优点：稳定，即不需要交换相同的元素。比如按工资排序，如果工资相同采用稳定的排序就会首先按照工资排序，工资相同者再按姓名排序。 可以传递给排序算法的列表（列表必须可以修改，但不必可以改变大小）： 如果列表支持set方法，则是可修改的。 如果列表支持add和remove，则是可改变大小的。

Collections类有一个算法shuffle，其功能与排序刚好相反，即随机地混排列表中的元素顺序。如果列表没有实现RandomAccess接口，shuffle方法将元素复制到数组中，然后打乱数组顺序，最后再将打乱顺序的元素复制回列表。

```java
List<Integer> numbers = new ArrayList<>();
for (int i = 0; i < 49; i++) {
    numbers.add(i);
}
Collections.shuffle(numbers);
List<Integer> winningCombination = numbers.subList(0, 6);
Collections.sort(winningCombination);
System.out.println(winningCombination);
// [7, 9, 25, 27, 30, 37]
```

### 二分查找

Collections类的binarySearch方法实现了这个算法。集合必须是排好序的，否则算法将返回错误的答案。要想查找某个元素，必须提供集合以及要查找的元素。如果集合没有采用Comparable接口的compareTo方法进行排序，就还要提供一个比较器对象。 如果binarySearch方法返回的数值大于等于0，则表示匹配对象的索引。c.get(i)等于在这个比较顺序下的element。如果返回负值表示没有匹配的元素。 但是可以利用返回值计算应该将element插入到集合的哪个位置，以保持集合的有序性。插入位置：

```java
if (i < 0) {
	c.add(-i -1, element);
}
```

### 简单算法

Collections类中有几个简单且有用的算法，查找最大元素、一个列表复制到另一个列表、用一个常量值填充容器、逆置一个列表元素顺序。 这些算法可以让程序员阅读算法变成一件轻松的事情。当阅读由别人实现的循环时，必须要揣摩编程者的意图。

### 批操作

从coll1中删除coll2中出现的所有元素： coll1.removeAll(coll2) 从coll1中删除所有未在coll2中出现的元素： coll1.retainAll(coll2) 找出两个集的交集（intersection）：

```java
Set<String> a = new HashSet<>();
a.add("Amy");
a.add("Bob");
Set<String> b = new HashSet<>();
b.add("Mack");
b.add("Bob");
Set<String> result = new HashSet<>(a);
result.retainAll(b);
System.out.println(result);
```

每个集都有一个构造器，其参数是包含初始值的另一个集合。

```java
// 员工ID映射到员工对象
Map<String, Employee> staffMap = ...;
// 不再聘用员工ID集
Set<String> terminatedIds = ...;
staffMap.keySet().removeAll(terminatedIds );
```

键集是映射的一个视图，所以键和相关联的员工会自动从映射中删除。

通过子范围视图，可以将批操作限制在子列表和子集上：

```java
List<Integer> relocated = new ArrayList<>();
relocated.addAll(list.subList(0, 10));
// 子范围还可以完成更改操作
list.subList(0, 10).clear();
System.out.println(list);
System.out.println(relocated);
// [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```


数组-&gt;集合：

```java
String[] values = ...;
HashSet<String> staff = new HashSet<>(Arrays.asList(values));
```

集合-&gt;数组：

```java
Object[] values = staff.toArray();
```

返回结果是一个Object[]数组，不能改变它的类型（不能使用强制类型转换）。实际上必须使用toArray方法的一个变体形式，提供一个所需类型而且长度为0的数组。返回的数组就会创建为相同的数组类型：

```java
String[] values = staff.toArray(new String[0]);
```

可以构造一个指定大小的数组，在这种情况下，不会创建新数组：

```java
staff.toArray(new String[staff.size()]);
```

### 编写自己的算法

编写自己的算法，应该尽可能地使用接口，而不要使用具体的实现。 用一组菜单项填充JMenu。传统上会以下列方式实现：

```java
void fillMenu(JMenu menu, ArrayList<JMenuItem> items) {
    for (JMenuItem item : items) {
        menu.add(item);
    }
}
```

这样会限制必须在ArrayList中提供选项。如果选择其他容器，必须对它们重新包装，最好接受一个更加通用的集合。

```java
void fillMenu(JMenu menu, Collection<JMenuItem> items) {
    for (JMenuItem item : items) {
        menu.add(item);
    }
}
```

返回集合的方法，可能还想要一个返回接口，而不是返回类的方法，因为这样做可以在日后改变想法，并用另一个集合重新实现这个方法。

```java
List<JMenuItem> getAllItems(JMenu menu) {
    List<JMenuItem> items = new ArrayList<>();
    for (int i = 0; i < menu.getItemCount(); i++) {
        items.add(menu.getItem(i));
    }
    return items;
}
```

日后若不复制所有菜单项，仅仅提供菜单项的视图，只需返回AbstractList的匿名子类：

```java
List<JMenuItem> getAllItems(final JMenu menu) {
    return new AbstractList<JMenuItem>() {
        @Override
        public JMenuItem get(int index) {
            return menu.getItem(index);
        }
        @Override
        public int size() {
            return menu.getItemCount();
        }
    };
}
```

## 6.遗留的集合


![img](https://img-blog.csdnimg.cn/20191212193635946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzemN5MTk5NTAz,size_16,color_FFFFFF,t_70)

### Hashtable类

Hashtable类与HashMap类作用一样，它们拥有相同的接口。与Vector类的方式一样。Hashtable方法也是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用HashMap。如果需要并发访问，则要使用ConcurrentHashMap。

### 枚举

遗留集合使用Enumeration接口对元素序列进行遍历。Enumeration接口有两个方法，即hasMoreElement和nextElement。这两个方法与Iterator接口的hasNext方法和next方法十分类似。

```java
Hashtable<String, Employee> staff = new Hashtable<>();
staff.put("123", new Employee("Amy"));
staff.put("456", new Employee("Bob"));
staff.put("789", new Employee("Mack"));
Enumeration<Employee> e = staff.elements();
while (e.hasMoreElements()) {
    Employee employee = e.nextElement();
    System.out.println(employee.getName());
}
```

有时还会遇到遗留的方法，其参数是枚举类型的。静态方法Collections.enumeration将产生一个枚举对象，枚举集合中的元素：

```java
List<InputStream> streams = ...;
SequenceInputStream in = new SequenceInputStream(Collections.enumeration(streams));
```

### 属性映射

==属性映射（property map）==是一个类型特别的映射结构。 键与值都是字符串。 表可以保存到一个文件中，也可以从文件中加载。 使用一个默认的辅助表。 实现属性映射的Java类成为Properties。属性映射通常用于程序的特殊配置选项。

### 栈

Stack类，有push方法和pop方法。Stack类扩展为Vector类，从理论角度看，Vector类并不太令人满意，它可以让栈使用不属于栈操作的insert和remove方法，即可以在任何地方进行插入和删除，不仅仅是在栈顶。

### 位集

Java平台的BitSet类用于存放一个位序列（它不是数学上的集，称为位向量或位数组更为合适）。如果需要高效地存储位序列就可以使用位集。由于位集将位包装在字节里，使用位集要比使用Boolean对象的ArrayList更高效。 BitSet类提供了一个便于读取、设置或清除各个位的接口。使用这个接口可以避免屏蔽和其他麻烦的位操作。如果将这些位存储在int或long变量中就必须进行这些繁琐的操作。 名为bucketOfBits的BitSet： bucketOfBits.get(i)如果第i位处于开状态，就返回true；否则返回false。 bucketOfBits.set(i)将第i位设置为开状态。 bucketOfBits.clear(i)将第i位置为关状态。

```java
public class Sieve {
    public static void main(String[] args) {
        int n = 2000000;
        long start = System.currentTimeMillis();
        BitSet b = new BitSet(n + 1);
        int count = 0;
        int i;
        for (i = 2; i <= n; i++) {
            b.set(i);
        }
        i = 2;
        while (i * i <= n) {
            if (b.get(i)) {
                count++;
                int k = 2 * i;
                while (k <= n) {
                    b.clear(k);
                    k += i;
                }
            }
            i++;
        }
        while (i <= n) {
            if (b.get(i)) {
                count++;
            }
            i++;
        }
        long end = System.currentTimeMillis();
        System.out.println(count + " 个素数");
        System.out.println((end - start) + " 毫秒");
        //148933 个素数
        //41 毫秒
    }
}
```

Eratosthenes筛子算法查找素数的实现。Eratosthenes筛子算法是最早用来枚举这些基本数字的方法之一。这不是最好的查找素数的方法，但是由于某种原因，它已经成为测试编译程序性能的一种流行基准（也不是最好的测试方法，它主要用于测试位操作）。 遍历一个拥有200万个位的位集，首先将所有位置为开状态。然后将已知素数的倍数所对应的位都置为关状态。经过这个操作保留下来的位对应的就是素数。

