---
layout:  post
title:   Java核心技术 基本程序设计结构
date:   2017-02-04 10:41:20
author:  'zhangtao'
header-img: 'img/post-bg-2015.jpg'
catalog:   false
tags:
-Java核心技术

---

## 1.一个简单的Java应用程序

```java
public class FirstSample {
    public static void main(String[] args) {
        System.out.println("We will not use 'Hello, world!'");// is this to cute?
    }
}
```

**关键字 public**：access modifier，访问修饰符，控制程序的其他部分对这段代码的访问级别

**关键字 class**：以字母（此处字母的范畴比较大，包括下划线”_”和美元符”$”）开头，后面跟字母和数字的任意组合，大小写敏感，长度无限制，不能使用Java的保留字

**命令java ClassName**：运行已编译的程序时，Java虚拟机将从指定类的main方法开始执行，因此为了代码能够执行，在类的源文件中必须包含一个main方法（必须声明为main）。

一个源文件可包含多个非public类，生成多个.class文件。

**System.out**：对象，并调用了他的println方法。

**注释**：

1.每行的注释前面标记//

2.使用/*和*/将一段比较长的注释括起来

3.可用来自动地生成文档，这种注释以/**开始，以*/结束。

&nbsp;

## 2.保留字

public

&nbsp;

## 3.数据类型

Java是一种强类型语言，必须为每一个变量声明一种类型。

1Byte（字节）&nbsp;= 8Bit（位）

### 整型

在Java中，整型的范围与运行Java代码的机器无关。

长整型后缀——L或l

十六进制前缀——0X或0x

八进制前缀——0

二进制前缀——0B或0b

从Java 7开始，还可以为数字字面量加下划线，例1_000_000

&nbsp;

### 浮点类型

float类型，4个字节，32位，第1位是符号位（数符），即S，接下来的8位是指数位（阶码）（double有11位指数位），即E，最后的23位，是小数域（尾数），即M。对于一个二进制数表示应该是1.XXX* 2^X，由于第一位永远都是1所以直接省去，因此表示为S.M*2^E。所以float的取值范围是-2^128到2^128，远远大于long的最大值。

能精确表示的浮点数，0.5的倍数，且在精度以内： *3.75* 

1.首先将数字转为2进制： 整数部分4： 3/2=1 余 1 1/2=0 余 1

小数部分0.75 0.75 * 2 = 1.5 未进位 1 0.50 * 2 = 1 进位整数 1

二进制表示：11.11

2.将二进制数转为科学计数法表示 科学记数法表示：1.111 * 2^1

3.转换为IEEE754格式存储 符号位 0 （正数0 负数1） 指数 1 （float指数+127 double指数+1023） 尾数 111

 *单精度float* :符号位0 指数位128(10000000) 尾数111 0 10000000 11100000000000000000000

 *双精度double* :符号位0 指数位1024(10000000000) 尾数111 0 10000000000 1110000000000000000000000000000000000000000000000000

不能精确表示的浮点数，1/3，十进制就无法精确表示三分之一这个数字。二进制也有很多很多小数无法精确表示，包括：0.1和0.2，这也是导致计算出现精度问题的根本原因。

0.2

0.20 * 2 = 0.40 未进位 0 0.40 * 2 = 0.80 未进位 0 0.80 * 2 = 1.60 进位 1 0.60 * 2 = 1.20 进位 1 0.20 * 2 = 0.40 未进位 0 0.40 * 2 = 0.80 未进位 0 0.80 * 2 = 1.60 进位 1 0.60 * 2 = 1.20 进位 1 0.20 * 2 = 0.40 未进位 0 0.40 * 2 = 0.80 未进位 0 0.80 * 2 = 1.60 进位 1 0.60 * 2 = 1.20 进位 1 0.20 * 2 = 0.40 未进位 0 0.40 * 2 = 0.80 未进位 0 0.80 * 2 = 1.60 进位 1 0.60 * 2 = 1.20 进位 1 0.20 * 2 = 0.40 未进位 0 无限循环... 二进制表示0.2: 0.00110011001100110011001100110011001100110011001100110011... 科学记数表示： 1.10011001100110011001100110011001100110011001100110011... * 2^-3

转换为IEEE754格式存储： 符号位 0 （正数0 负数1） 指数 -3 （float指数+127 double指数+1023） 尾数 10011001100110011001100110011001100110011001100110011...

float 单精度浮点数，尾数只能存储23位，多余位数四舍五入: 0 01111100 10011001100110011001101

double 双精度浮点数，尾数只能存储52位，多余位数四舍五入: 0 01111111100 1001100110011001100110011001100110011001100110011010

使用下面代码可以直接查看float和double数值对应的二进制形式：

```java
float f = 3.75F;
int fb = Float.floatToIntBits(f);
System.out.println(Integer.toBinaryString(fb));
double a = 0.2;
long b = Double.doubleToLongBits(a);
System.out.println(Long.toBinaryString(b));
```

float后缀——F或f，没有后缀的浮点数值默认为double。也可以在浮点数值后添加后缀D或d。

用于表示溢出和出错情况的三个特殊浮点数值：

1.正无穷大 Double.POSITIVE_INFINITY

2.负无穷大 Double.NEGATIVE_INFINITY

3.NaN Double.NaN

但是不能这样检测一个特定值是否等于Double.NaN，

```java
if (x == Double.NaN)
```

因为所有非数值的值都认为不相同，

```java
Double.NaN == Double.NaN //结果为false
```

可以使用Double.isNaN方法：

```java
Double.isNaN(Double.NaN) //true
```

&nbsp;

### char类型

表示单个字符，采用Unicode编码，每个字符占两个字节

**转义字符**

Unicode转义序列会在解析代码之前得到处理。

```java
System.out.println("\u0022+\u0022");
```

并不是一个由引号(U+0022)包围加号构成的字符串。实际上\u0022会在解析之前转换为"，这会得到""+""，也就是一个空串。

```java
// Look inside c:\users
```

这会产生一个语法错误，因为\u后面未跟着4个十六进制数。

**码点(code point)**，指与一个编码表中的某个字符对应的代码值。在Unicode标准中，采用十六进制书写，前加前缀U+，例如U+00041就是拉丁字母A的码点。

码点分为17个代码级别，第一个称为基本的多语言级别，码点从U+0000~U+FFFF，其中包括经典的Unicode码；其余16个级别码点从U+10000到U+10FFFF，其中包括一些辅助码点。

UFT-16编码采用不同长度的编码表示所有Unicode码点。在基础的多语言代码级别中，每个字符用16为表示，通常被称为代码单元。而辅助字符采用一对连续的代码单元进行编码。这样构成的编码落入基本的多语言级别中空闲的2048字节内，被称为替代区域。例如表八元数级的一个数字符号，码点为U+1D546，编码为两个代码单元U+D835和U+DD46。

在Java中，char类型描述了UTF-16编码中的一个代码单元。

&nbsp;

### boolean类型

整型值和布尔值之间不能进行转换。

## 

## 4.变量

变量名必须是一个字母开头并由字母或数字构成，字母包括**A~Z、a~z、_ 、$** 或在某些语言中表示字母的任何Unicode字符，例如希腊人可以用 ‘π’。同样，数字包括0~9和某语言中表示数字的任何Unicode字符。，但是**+和©**不能出现在变量中，空格也不行。

可以用Character类的**isJavaIdentifierStart**和**isJavaIdentifierPart**方法来检查。

## 5.运算符

当参与/运算的两个操作数都是整型，表示整数除法，否则，表示浮点除法。

%，表示求余操作，（取模）。

整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果：

```java
int i = 1;
double s = 1.2;
        
// System.out.println(i / 0);
System.out.println(s / 0);
```

输出：Infinity (无穷)

&nbsp;

### 数学函数

```java
double x = 4;
double y = Math.sqrt(x);
System.out.println(y); //输出 2.0
```

println方法处理System.out对象，而Math类中的sqrt方法处理的不是对象，而是静态方法。

pow(x,a)，幂运算，x的a次幂

sqrt，平方根

三角函数，Mtah.sin, Math.cos, Math.tan, Math.atan, Math.atan2

指数函数以及反函数——自然对数以及以10为底的对数，Math.exp, Math.log, Math.log10

π，Math.PI

e常量，Math.E

floorDiv(x,y)，返回等于或小于代数商的最大整数

```java
int r = x / y;
// 如果符号不同且模不为零，则向下舍入
if ((x ^ y) < 0 && (r * y != x)) {
    r--;
}
return r;
```

floorMod，解决一个长期存在的有关整数余数的问题。n % 2，如果n为负奇数，则表达式为-1。但是数学家们几百年都知道一个最优（或“欧几里得”）规则：余数总要&gt;=0。最早指定计算机规则的人并没有翻开数学书好好研究，而是提出了看似合理但实际上很不方便的规则。

floorMode的源码：

```java
public static int floorMod(int x, int y) {
    int r = x - floorDiv(x, y) * y;
    return r;
}
```

```java
int n = -13;
System.out.println(n % 2);
System.out.println(Math.floorMod(n, 2));
// -1
// 1
```

&nbsp;

### 数值类型之间的转换

Boolean类型不可以转换

byte,short,char-&gt;int-&gt;**long->float**（float类型能表示的数的最大值远远大于long，涉及到浮点数在内存中的存储问题）-&gt;double容量小的在混合运算时自动转换成容量大的数据类型。

byte,short,char之间不会互相转换，他们三者计算时首先转换成int类型

容量大的的转换成容量小的，要加**强制转换符**：

1.浮点型强制转换成整型会舍去小数部分；

2.long-&gt;int-&gt;byte的转换直接将多余的字节去掉，是可以转换的；

3.double-&gt;float，可能会出现很大误差，正确的做法是将float型转换为字符串型，再转换为精度更高的BigDecimal型，再将其转换为double型。

```java
int i1=12;
int i2=34;
double d1=(i1+i2)*1.2;
float f1=(float)(i1+i2);
System.out.println(d1+","+f1);
byte b1=67;
byte b2=89;
//系统将转换成int型运算，需要强制转换符
byte b3=(byte)(b1+b2);
System.out.println(b3);
double d2=1e200;
//会产生溢出
float f2 = (float)d2;
System.out.println(f2);
//必须加f
float f3=1.23f;
long l1=123;
//必须加l
long l2=300000000L;
float f = l1+l2+f3;
//强制转换会舍去小数部分(不是四舍五入)
long l = (long)f;
System.out.println(l);
// 55.199999999999996,46.0
// -100
// Infinity
// 300000128
```

int转byte原则：

最高位为0则为整数，整数等于原值

266＝（00000000）（00000000）（00000001）（00001010）=10

最高位为1则为负数，负数是以补数的形式表示的（补码变原码除符号位不变，按位取反末位加1） 156=（00000000）（00000000）（00000000）（10011100）=（11100100）= -（64+32+4） = -100

&nbsp;

### 自增与自建运算符

```java
int m = 7;
int n = 7;
int a = 2 * ++m;
int b = 2 * n++;
System.out.println(a + ", " + m);
System.out.println(b + ", " + n);
// 16, 8
// 14, 8
```

前缀形式会先完成加1，而后缀形式会使用变量原来的值。

&nbsp;

### 关系和boolean运算符

检查相等性，==

检查不相等，!=

**关系运算符：**&gt;,&lt;,&gt;=,&lt;=

逻辑运算符：！逻辑非，&amp;&amp;逻辑与，||逻辑或，&amp;&amp;和||是按照短路方式求值的，如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。

三元操作符：condition ? expression1 : expression2，如果条件为true，就为第一个表达式的值，否则为第二个表达式的值。

&nbsp;

### 位运算符

&amp;与

|或

^异或(相同为0相异为1)

~非

不过&amp;和 | 运算符不采用短路方式求值。

n是一个整数变量，如果用二进制表示的n，从右边数第四位为1，则会返回1，否则返回0。

&gt;&gt;和&lt;&lt;运算符将位模式左移或右移，需要建立位运算来完成位掩码时，这两个运算符会很方便：

```java
int n = 23;
int fourthBitFromRight = (n & 0b1000) / 0b1000;
int fourthBitFromRight1 = (n & (1 << 3)) >> 3;
System.out.println(fourthBitFromRight);
System.out.println(fourthBitFromRight1);
```

最后，&gt;&gt;&gt;运算符会用0填充高位，这与&gt;&gt;不同，它会用符号位填充高位，不存在&lt;&lt;&lt;运算符。

&nbsp;

### 括号与运算符级别


