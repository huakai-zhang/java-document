---
layout:  post
title:   Java核心技术 对象与类2
date:   2017-02-04 10:41:29
author:  'zhangtao'
header-img: 'img/post-bg-2015.jpg'
catalog:   false
tags:
-Java核心技术

---

## 4.静态域与静态方法

### 静态域

如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有一份自己的拷贝。

```java
class Employee {
    private static int nextId = 1;
    private int id;
}
```

每一个雇员对象都有一个自己的id域，但这个类的所有实例将共享一个nextId域。即使没有一个雇员对象，静态域nextId也存在。它属于类，不属于任何一个独立的对象。

```java
class Employee {
    private static int nextId = 1;
    private int id;
    public void setId() {
        this.id = nextId;
        nextId++;
    }
    public int getId() {
        return id;
    }
    public static void main(String[] args
        Employee e1 = new Employee();
        e1.setId();
        
        Employee e2 = new Employee();
        e2.setId();
        System.out.println(e1.getId());
        System.out.println(e2.getId());
    }
    // 1
    // 2
}
```

&nbsp;

### 静态常量

```java
public static final double PI = 3.14159265358979323846;
```

程序中可以采用Math.PI获取这个常量。如果关键字static被省略，PI就变成了Math类的一个实例域。需要通过Math类的对象访问PI，并且每一个Math对象都有它自己的一份PI拷贝。

```java
public class System {
    ...
    public static final PrintStream out = ...;
    ...
}
```

前面说最好不要将域设计为public，然而对于公有常量（final域）却没问题。因为out被声明为final，所以，不允许在将其他打印流赋给它：

```java
System.out = new PrintStream(); // 错误
```

&nbsp;

### 静态方法

静态方法是一种不能向对象实施操作的方法。换句话说就是没有隐式参数。

可以认为静态方法是没有this参数的方法（在一个非静态方法中，this参数表示这个方法的隐式参数。）

Employee类的静态方法不能访问Id实例域，因为它不能操作对象。但是静态方法可以访问自身类中的静态域。

```java
public static int getNextId() {
    return nextId;
}

int n = Employee.getNextId();
```

这个方法可以省略掉static。但是需要通过Employee类对象的引用调用这个方法。

在下面两种情况下使用静态方法：

1.一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（Math.pow）

2.一个方法只需要访问类的静态域（Employee.getNextId）

&nbsp;

### 工厂方法

静态方法还有另一个常见的用途。类似LocalDate和NumberFormat的类使用静态工厂方法类构造对象。

NumberFormat类使用工厂方法生成不同风格的格式化对象：

```java
NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x = 0.1;
System.out.println(currencyFormatter.format(x));
System.out.println(percentFormatter.format(x));
// ￥0.10
// 10%
```

NumberFormat不使用构造器只要有两个原因：

1.无法命名构造器，构造器的名称必须与类名相同。但是这里希望得到货币和百分比实例采用不同的名字。

2.当使用构造器时，无法改变所构造对象类型。而Factory方法将返回一个DecimaFormat类对象，他是NumberFormat的子类。

&nbsp;

### main方法

不需要使用对象调用静态方法。

main方法是一个静态方法，不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需的对象。

每个类可以有一个main方法，这是一个常用于对类进行单元测试的技巧。

&nbsp;

## 5.方法参数

**按值调用（call by value）**，表示方法接收的是调用者提供的值。

**按引用调用（call by reference）**，表示方法接收的是调用者提供的变量地址。

一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。

Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。

```java
public static void main(String[] args) {
    double percent = 10;
    tripleValue(percent);
    System.out.println(percent);
}
static void tripleValue(double x) {
    x = 3 * x;
}
```

方法参数共有两种类型：

1.基本数据类型

2.对象引用

一个方法不可能修改一个基本数据类型的参数。而对象引用作为参数就不同了。

```java
public static void main(String[] args) {
    Employee harry = new Employee("Carl Cracker", 75000, 1987, 12, 15);
    tripleSalary(harry);
    System.out.println(harry.getSalary());
}
static void tripleSalary(Employee x) {
    x.raiseSalary(200);
}
// 225000.0
```

具体执行过程为：

1.x被初始化为harry值的拷贝，这里是一个对象的引用

2.raiseSalary方法应用于这个对象引用。x和harry同时引用的那个雇员对象的薪水提高了200%

3.方法结束后，参数变量x不再使用。当然对象变量harry继续引用那个薪水增至3倍的雇员对象

方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。

&nbsp;

Java对象并不是采用引用调用：

```java
public static void main(String[] args) {
    Employee a = new Employee("Carl Cracker", 75000, 1987, 12, 15);
    Employee b = new Employee("Harry Hacker", 50000, 1989, 10, 1);
    swap(a, b);
    System.out.println(a.getName());
    System.out.println(b.getName());
}

static void swap(Employee x, Employee y) {
    Employee temp = x;
    x = y;
    y = temp;
}
// Carl Cracker
// Harry Hacker
```

如果Java使用的是按引用调用，那么这个方法应该可以实现交换数据的效果。但方法并没有改变存储在变量a和b中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝。这个方法交换的是这个拷贝。

这个过程说明：Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。

&nbsp;

Java中方法参数的使用情况：

1.一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）

2.一个方法可以改变一个对象参数的状态

3.一个方法不能让对象参数引用一个新的对象

&nbsp;

## 5.对象构造

### 重载

有些类有多个构造器：

```java
StringBuilder messages = new StringBuilder();
StringBuilder todoList = new StringBuilder("To do:\n");
```

这种特性叫做**重载（overloading）**，如果多个方法有相同的名字、不同的参数，便产生了重载。

重载解析（overloading resolution），编译器通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出响应的方法。如果找不到匹配的参数，就会产生编译错误。

Java允许任何方法重载。要描述一个方法需要指出方法名以及参数，这叫做方法的**签名（signature）**。返回类型不是方法签名的一部分，也就是说，不能有两个方法名字相同参数类型也相同却返回不同类型值的方法。

&nbsp;

### 默认域初始化

如果构造器没有显式地给域赋值初值，那么就会被自动赋值为默认值：数值为0、布尔值为false、对象引用为null。

这是域与局部变量的主要不同点，必须明确地初始化方法中的局部变量。

```java
Employee harry = new Employee();
LocalDate h = harry.getHireDay();
int year = h.getYear(); // 空指针异常
```

这并不是一个好习惯，getHireDay()方法会得到一个null引用。

&nbsp;

### 无参数的构造器

对象由无参数构造器函数创建时，其状态会设置为适当的默认值。

如果在编写一个类时没有编写构造器，那么系统会提供一个无参数构造器。

如果类中提供了至少一个构造器，但没有提供无参数构造器，则在构造对象时如果没有提供参数就会被视为不合法。

&nbsp;

### 显式域初始化

每个实例域都可以被设置为一个有意义的初值，这是一种很好的习惯。

可以在类定义中，直接将一个值赋值给任何域：

```java
class Employee {
    private String name = "";
    ...
}
```

在执行构造器之前，先执行赋值操作。当一个类的所有构造器都希望把相同的值赋予某个特定实例域时，特别好用。

初始值不一定是常量：

```java
class Employee {
    private static int nextId;
    private int id = assignId();
    
    private static int assignId() {
        int r = nextId;
        nextId++;
        return r;
    }
}
```

&nbsp;

### 参数名

```java
public Employee(String n, double s) {
    name = n;
    salary = s;
}
```

这样过于简单，只有阅读代码才能了解n和s的含义。

有些习惯前面加a：

```java
public Employee(String aName, double aSalary) {
    name = aName;
    salary = aSalary;
}
```

还有一种技巧：参数变量用同样的名字将实例域屏蔽起来，例如参数命名为salary，salary将引用这个参数，而不是实例域，但可以采用this.salary的形式访问实例域，this指示隐式参数，也就是所构造的对象：

```java
public Employee(String name, double salary) {
    this.name = name;
    this.salary = salary;
}
```

&nbsp;

### 调用另一个构造器

关键字this引用方法的隐式参数。

如果构造器的第一个语句形如this(...)，这个构造器将调用同一个类的另一个构造器：

```java
public Employee(double s) {
    this("Employee #" + nextId, s);
    nextId++;
}
```

当调用new Employee(60000)时，Employee(double)构造器将调用Employee(String, double)即可。

&nbsp;

### 初始化块

前面提到两张初始化数据域的方法：

1.在构造器中设置值

2.在声明中赋值

Java还有第三种机制，**初始化块（initialization block）**，在一个类的声明中，可以包含多个代码块，只要构造类的对象，这些块就会被执行：

```java
class Employee {
    private int id;
    private String name;
    private double salary;
    private static int nextId;
    
    {
        id = nextId;
        nextId++;
    }
    
    public static void main(String[] args) {
        Employee e1 = new Employee();
        Employee e2 = new Employee();
        System.out.println(e1.getId());
        System.out.println(e2.getId());
        // 0
        // 1
    }
}
```

无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化，首先运行初始化块，然后执行构造器部分。

&nbsp;

调用构造器的具体步骤：

* 类初始化过程，只执行一次
  * 父类依次执行所有域静态初始化语句和静态初始化块
  * 依次执行所有域静态初始化语句和静态初始化块

* 实例初始化过程

  * 父类所有数据域被初始化默认值
  * 父类按照在类声明中出现的次序，依次执行父级所有域初始化语句和初始化块
  * 实例初始化构造器中调用了父级构造器，执行对应父级构造器，未调用则执行默认父级构造器

  * 所有数据域被初始化默认值

  * 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块

  * 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体

  * 执行这个构造器主体

如果让类的构造器行为依赖于数据域声明的顺序，那就显得奇怪并且容易引起错误，可以通过提供一个初始值：

```java
private static int nextId = 1;
```

或使用**静态初始化块**，将代码放到一个块中，并标记为static：

```java
static {
    Random generator = new Random();
    nextId = generator.nextInt(10000);
}
```

在类第一次加载的时候，将会进行静态域的初始化。与实力域一样，除非将它们显式设置，否则是默认的初始值。所有的静态初始化语句以及静态初始化块都依照类定义的顺序执行。

&nbsp;

### 对象析构与finalize方法

Java有自动的垃圾回收器，不需要人工回收内存，所有Java不支持析构器。

当然有些对象是有了内存之外的其他资源，当此资源不再需要时，将其回收或再利用将显得十分重要。可以为任何一个类添加**finalize**方法，在垃圾回收器清除对象之前调用，在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，因为很难知道这个方法什么时候调用。

某个资源在使用完毕后立刻被关闭，那么需要人工管理，对象用完时，可以用于一个close方法来清理。

