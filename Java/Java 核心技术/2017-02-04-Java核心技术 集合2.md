---
layout:  post
title:   Java核心技术 集合2
date:   2017-02-04 17:25:41
author:  'zhangtao'
header-img: 'img/post-bg-2015.jpg'
catalog:   false
tags:
-Java核心技术

---

### 数组列表

List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机地访问每个元素。后者不适合链表，但对数组却很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。

在需要动态数组时，会用ArrayList取代Vector：

Vector类的所有方法都是同步的，可以由两个线程安全地访问一个Vector对象。但是由一个线程访问Vector，代码在同步操作上耗费大量的时间。而ArrayList方法不是同步的。因此，建议在不需要同步时使用ArrayList，而不要使用Vector。

&nbsp;

### 散列集

如果不在意元素的顺序，可以有几种能够快速查找元素的数据结构。其缺点是无法控制元素出现的次序，它们将按照有利于其操作目的的原则组织数据。

散列表（hash table）为每个对象计算一个整数，成为散列码（hash code）。散列码是由对象的实例域产生的一个整数。更准确地说，具有不同数据域的对象将产生不同的散列码。

自定义类需要实现hashCode方法，自己实现的hashCode应与equals方法兼容，即如果a.equals(b)为true，a与b必须具有相同的散列码。

Java中，散列表用链表数组实现。每个列表被称为桶（bucket）。


![img](https://img-blog.csdnimg.cn/20191207105249341.png)

散列码与桶的总数取余，所得到的结果就是保存这个元素的桶的索引。如果在桶中没有其他元素，此时将元素直接插入桶中即可。

有时桶可能被占满，这种现象被称为散列冲突（hash collision）。此时需要新对象与桶中所有对象进行比较，查看这个对象是否已经存在。

如果散列码是合理且随机分布的，桶的数目也足够大，需要比较的次数就会很少。在Java SE 8中，桶满时会从链表变为平衡二叉树。如果选择的散列函数不当，会产生很多冲突。

想要更多地控制散列表的运行性能，就要指定一个初始的桶数。桶数是指用于收集具有相同散列值的桶的数目。如果要插入散列表中的元素太多，就会增加冲突的可能性，降低运行性能。

如果知道大致会有多少个元素就可以设置桶数，一般桶数为预计元素个数的75%~150%。尽管没有确凿的证据，但最好将桶数设置为一个素数，以防键的集聚。标准类库使用的桶数是2的幂，默认为16（为表大小提供的任何值都将被自动地转换为2的下一个幂）。

如果散列表太满，就需要再散列（rehashed）。创建一个桶数更多的表，并将所有元素插入到新表中，然后丢弃原来的表。

装填因子（load factor）决定何时对散列表进行再散列，对于大多数程序来说，0.75（默认值）是比较合理的，即表中超过75%的位置已经填入，这个表就会用双倍的桶数自动的进行再散列。

散列表最简单的数据结构是set类型。set是没有重复元素的集合，set的add方法首先在集中查找要添加的对象，如果不存在，将这个元素加进去。

Java集合类库提供了HashSet类，它实现了基于散列表的集。add方法添加元素，contains方法被重新定义，用来快速地查看是否某个元素已经出现在集中。它只在某个桶中查找元素，而不必查看集中的所有元素。

散列集迭代器依次访问所有的桶，由于散列将元素分散在表的各个位置，所以顺序几乎是随机的。只有不关心集合顺序时才应该使用HashSet。

在更改集中的元素时要格外小心，如果元素的散列码发生了改变，元素在数据结构的位置也会发生变化。

```java
public class SetTest {
    public static void main(String[] args) {
        Set<String> words = new HashSet<>();
        long totalTime = 0;
        try (Scanner in = new Scanner(new File("alice30.txt"))) {
            while (in.hasNext()) {
                String word = in.next();
                long callTime = System.currentTimeMillis();
                words.add(word);
                callTime = System.currentTimeMillis() - callTime;
                totalTime += callTime;
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        Iterator<String> iter = words.iterator();
        for (int i = 0; i < 20 && iter.hasNext(); i++) {
            System.out.println(iter.next());
        }
        System.out.println("...");
        System.out.println(words.size() + "个不同的词，" + totalTime + "毫秒。");
    }
}
```

### 树集

TreeSet类与散列集十分类似，它比散列集有所改进。树集是一个有序集合，可以以任意顺序将元素插入到集合中。在对集合进行遍历时，每个值将自动地按照排序后的顺序呈现：

```java
SortedSet<String> sorter = new TreeSet<>();
sorter.add("Bob");
sorter.add("Amy");
sorter.add("Carl");
for (String s : sorter) {
    System.out.println(s);
}
// Amy
// Bob
// Carl
```

&nbsp;

排序是用树结构完成的（红黑树（red-black tree））。每次将一个元素添加到树中时，都被放置在正确的排序位置上。因此，迭代器总是以排好序的顺序访问每个元素。

将一个元素添加到树中要比添加到散列表中慢，但是与检查数组或链表中的重复元素相比还是快很多。如果树中包括n个元素，查找新元素的正确位置平均需要log₂n次比较（log₂1000 = 10）。


![img](https://img-blog.csdnimg.cn/20191207125208312.png)

要使用树集必须能够比较元素。这些元素必须实现Comparable接口，或者构造集时必须提供一个Comparator。

那为什么不用树集取代散列集，因为添加一个元素所花费的时间看上去并不是很长，而且元素是自动排序？

怎么取舍取决于所要收集的数据。如果不需要对数据进行排序，就没有必要付出排序的开销。对于某些数据对其排序要比散列函数更加困难。

树的排序必须是全序，也就是说任意两个元素必须是可比的（TreeSet需要提供Comparator），有些计算很牵强且繁琐。相反地，很多类已经定义了散列函数，它直接进行散列。

Java SE 6起，TreeSet类实现了NavigableSet接口，这个接口增加了几个便于定位元素以及反向遍历的方法。

```java
public class TreeSetTest {
    public static void main(String[] args) {
        SortedSet<Item> parts = new TreeSet<>();
        parts.add(new Item("Toaster", 1234));
        parts.add(new Item("Widget", 4562));
        parts.add(new Item("Modem", 9912));

        NavigableSet<Item> sortByDescription = new TreeSet<>(Comparator.comparing(Item::getDescription));
        sortByDescription.addAll(parts);
        System.out.println(sortByDescription);
    }
}

public class Item implements Comparable<Item> {
    private String description;
    private int partNumber;

    public Item(String description, int partNumber) {
        this.description = description;
        this.partNumber = partNumber;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "description='" + description + ", partNumber=" + partNumber;
    }

    @Override
    public boolean equals(Object otherObject) {
        if (this == otherObject) {
            return true;
        }
        if (otherObject == null) {
            return false;
        }
        if (getClass() != otherObject.getClass()) {
            return false;
        }
        Item other = (Item) otherObject;
        return Objects.equals(description, other.description) && partNumber == other.partNumber;
    }

    @Override
    public int hashCode() {
        return Objects.hash(description, partNumber);
    }

    @Override
    public int compareTo(Item o) {
        int diff = Integer.compare(partNumber, o.partNumber);
        return diff != 0 ? diff : description.compareTo(o.description);
    }
}
```

&nbsp;

### 队列与双端队列

有两个端口的队列，即双端队列，可以在头部和尾部同时添加或删除元素（队列，头部删除，尾部添加）。不支持在队列中间添加元素。

在Java SE 6引入了Deque接口，并由ArrayDeque和LinkedList类实现，这两个类都提供了双端队列，而且在必要时可以增加队列长度。

&nbsp;

### 优先级队列

优先级队列（priority queue）中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。无论如何调用remove方法，总会获得当前优先级队列中最小的元素。

优先级队列并没有对元素进行排序，优先级队列使用了一种优雅且高效的数据结构，成为堆（heap）。堆是一个可以自我调整的二叉树，对树执行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。与TreeSet一样，优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象。

优先级队列的典型事例是任务调度。每个任务有一个优先级，任务以随机顺序添加进队列，每当启动一个新任务，都将优先级最高的任务从队列中删除（习惯上1为最高优先级，即最小）。

与TreeSet的迭代不同，优先级队列的迭代并不是按照元素的排列顺序访问的，而删除却总是删除剩余元素中优先级数最小的那个元素。

```java
public class PriorityQueueTest {
    public static void main(String[] args) {
        PriorityQueue<LocalDate> pq = new Priorit
        pq.add(LocalDate.of(2019, 03, 13));
        pq.add(LocalDate.of(2019, 02, 17));
        pq.add(LocalDate.of(2019, 06, 24));
        pq.add(LocalDate.of(2019, 04, 30));
        for (LocalDate date: pq) {
            System.out.println(date);
        }
        System.out.println("...");
        while (!pq.isEmpty()) {
            System.out.println(pq.remove());
        }
        // 2019-02-17
        // 2019-03-13
        // 2019-06-24
        // 2019-04-30
        // ...
        // 2019-02-17
        // 2019-03-13
        // 2019-04-30
        // 2019-06-24
    }
}
```

&nbsp;

## 3.映射

映射（map）数据结构，用来存放键/值对。如果提供了键，就能查找到值。

### 基本映射操作

Java类库为映射提供了两个实现：HashMap和TreeMap。这两个类都实现了Map接口。

散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。

与集一样，散列稍微快一些，如果不需要按照排列顺序访问键，就最好选择散列。

如果映射中没有与给定键对应的信息，get将返回null。有时可以有一个好的默认值，用作映射不存在的键，然后使用getOrDefault方法：

```java
Map<String, Integer> scores = new HashMap<>();
System.out.println(scores.get("a"));
System.out.println(scores.getOrDefault("a", 0));
// null
// 0
```

键必须是唯一的。不能一个键存放两个值。如果对同一个键两次调用put方法，第二个值会取代第一个值。实际上，put将返回用这个键参数存储的上一个值。

```java
Map<String, Integer> scores = new HashMap<>();
System.out.println(scores.put("a", 0));
System.out.println(scores.put("a", 1));
// null
// 0
```

remove方法用于从映射中删除给定键对应的元素。

size方法用于返回映射中的元素数。

forEach迭代，提供一个接收键和值的lambda表达式：

```java
scores.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));
```

```java
public class MapTest {
    public static void main(String[] args) {
        Map<String, Employee> staff = new HashMap<>();
        staff.put("144-25-5464", new Employee("Amy Lee"));
        staff. put("567-24-2546", new Employee("Harry Hacker"));
        staff. put("157-62-7935", new Employee("Cary Cooper"));
        staff.put("456-62-5527", new Employee("Francesca Cruz"));

        System.out.println(staff);

        staff.remove("567-24-2546");

        staff.put("456-62-5527", new Employee("Francesca Miller"));

        System.out.println(staff.get("157-62-7935"));

        staff.forEach((k, v) -> System.out.println("key=" + k + ", value=" + v));
    }
}
```

### 更新映射项

处理映射时的一个难点就是更新映射项。正常情况下与一个键关联的原值，完成更新，再放回更新后的值。

例如：使用一个映射统计一个单词在文件中出现的频度，看到一个单词将计数器增1：

```java
counts.put(word, counts.get(word) + 1);
```

如果第一次看到word时，get会返回null，因此会出现一个NullPointerException。

```java
// 补救方法，1.使用getOrDefault方法
counts.put(word, counts.getOrDefault(word, 0) + 1);
// 2.调用putIfAbsent，只有当键原先不存在时才会放入一个值
counts.putIfAbsent(word, 0);
counts.put(word, counts.get(word) + 1);
// 3.merge方法，如果键原先不存在调用时，将把word与1关联，否则使用Integer::sum函数组合原值和1（也就是将原值与1求和）
counts.merge(word, 1, Integer::sum);
```

### 映射视图

集合框架不认为映射本身是一个集合。不过可以得到映射的视图（view）——实现了Collection接口或某个子接口的对象。

有三种视图：键集、值集合以及键/值对集。键和键/值对可以构成一个集，因为映射中一个键只能有一个副本。

条目集的元素是实现Map.Entry接口的类的对象。

keySet不是HashSet或TreeSet，而是实现了Set接口的另外某个类的对象。Set接口扩展了Collection接口。因此，可以像使用集合一样使用keySet。

枚举一个映射的所有键：

```java
Set<String> keys = map.keySet()
for(String key : keys) {}
```

如果想同时查看键和值，可以通过枚举条目来避免查找值：

```java
for(Map.Entry<String, Employee> entry : staff.entrySet()) {
    String k = entry.getKey();
    Employee v = entry.getValue();
}
```

原来这是访问映射条目的最高效方法。如今只需要使用forEach方法：

```java
staff.forEach((k, v) -> { });
```

如果在键集视图上调用迭代器的remove方法，实际上会从映射中删除这个键和与它相关的值。不能向键集视图增加元素。如果试图调用add方法会抛出一个UnsupportedOperationException（条目视图有同样的限制）。

&nbsp;

### 弱散列映射

专用的映射类WeakHashMap

如果有一个值，对应的键已经不再使用，由于程序中任何部分没有在出现这个键，所以这个键值对无法从映射中删除。垃圾回收器跟踪活动的对象，只要映射对象是活动的，其中的所有桶也是活动的，他们不能被回收。因此需要程序负责从长期存活的映射表中删除那些无用的值。或者使用WeakHashMap完成，当对键的唯一引用来自散列条目时，这一数据结构与垃圾回收器协同工作一起删除键值对。

WeakHashMap使用弱引用（weak references）保存键，WeakReference对象将引用保存到另外一个对象中。在这里就是散列键。对于这种类型的对象，垃圾回收器有一种特有的方式进行处理。通常如果垃圾回收器发现某个特定的对象已经没人引用了，就将其回收。然而如果某个对象只有WeakReference引用，垃圾回收器仍然回收它，但要将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找到新添加的弱引用。一个弱引用进入队列意味着这个键不再被人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。

&nbsp;

### 链接散列集与映射

LinkedHashSet和LinkedHashMap类用来记住插入元素项的顺序。这样可以避免在散列表中的项从表面上看是随机排列的。当条目插入到表中时，就会并入到双向链表中。


![img](https://img-blog.csdnimg.cn/20191209221102325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dzemN5MTk5NTAz,size_16,color_FFFFFF,t_70)

```java
Map<String, Employee> staff = new LinkedHashMap<>();
staff.put("144-25-5464", new Employee("Amy Lee"));
staff. put("567-24-2546", new Employee("Harry Hacker"));
staff. put("157-62-7935", new Employee("Cary Cooper"));
staff.put("456-62-5527", new Employee("Francesca Cruz"));
staff.forEach((k, v) -> {
    System.out.println(k);
});
// 144-25-5464
// 567-24-2546
// 157-62-7935
// 456-62-5527
```

构造这样一个的散列映射表：LinkedHashMap&lt; K, V &gt;(initialCapacity, loadFactor, true)，链接散列映射将用访问顺序， 而不是插入顺序， 对映射条目进行迭代。每次调用 get或put, 受到影响的条目将从当前的位置删除， 并放到条目链表的尾部（只有条目在链表中的位置会受影响， 而散列表中的桶不会受影响。一个条目总位于与键散列码对应的桶中）。

```java
Map<String, Employee> staffs = new LinkedHashMap<>(4, 0.75f, true);
staffs.put("144-25-5464", new Employee("Amy Lee"));
staffs.put("567-24-2546", new Employee("Harry Hacker"));
staffs.put("157-62-7935", new Employee("Cary Cooper"));
staffs.put("456-62-5527", new Employee("Francesca Cruz"));
staffs.get("157-62-7935");
staffs.forEach((k, v) -> System.out.println(k));
// 144-25-5464
// 567-24-2546
// 456-62-5527
// 157-62-7935
```

 访问顺序对于实现高速缓存的“ 最近最少使用” 原则十分重要。当在表中找不到元素项且表又已经满时， 可以将迭代器加入到表中， 并将枚举的前几个元素删除掉。这些是近期最少使用的几个元素。 构造一个LinkedHashMap 的子类，然后覆盖下面这个方法： protected boolean removeEldestEntry(Map.Entry&lt; K， V &gt; eldest) 每当方法返回 true 时，就添加一个新条目，从而导致删除 eldest 条目。下面的高速缓存可以存放 100 个元素：

```java
Map<K, V> cache = new LinkedHashMapo(128, 0.75F, true){
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest){
        return size() > 100;
    }
}();
```

另外，还可以对 eldest 条目进行评估，以此决定是否应该将它删除。

### 枚举集与映射

EmimSet 是一个枚举类型元素集的高效实现。 由于枚举类型只有有限个实例， 所以EnumSet 内部用位序列实现。如果对应的值在集中， 则相应的位被置为 1。 EnumSet 类没有公共的构造器。可以使用静态工厂方法构造这个集：

```java
public class EnumSetTest {
    public static void main(String[] args) {
        EnumSet<Weekday> always = EnumSet.allOf(Weekday.class);
        EnumSet<Weekday> never = EnumSet.noneOf(Weekday.class);
        EnumSet<Weekday> workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);
        EnumSet<Weekday> mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);
        EnumMap<Weekday, Employee> personInCharge = new EnumMap<>(Weekday.class);
    }
}
enum Weekday {
    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY
}
```

EnumMap 是一个键类型为枚举类型的映射。它可以直接且高效地用一个值数组实现。在使用时， 需要在构造器中指定键类型： EnumMap&lt; Weekday, Employee &gt; personlnCharge = new EnumMapo(Weekday.class);

&nbsp;

### 标识散列映射

 类IdentityHashMap有特殊的作用。在这个类中， 键的散列值不是用hashCode函数计算的， 而是用 System.identityHashCode 方法计算的。 这是 Object.hashCode 方法根据对象的内存地址来计算散列码时所使用的方式。而且， 在对两个对象进行比较时， IdentityHashMap 类使用 ==, 而不使用 equals。 也就是说， 不同的键对象， 即使内容相同， 也被视为是不同的对象。 在实现对象遍历算法（如对象串行化）时， 这个类非常有用， 可以用来跟踪每个对象的遍历状况。

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

&nbsp;

