---
layout:  post
title:   Java编程思想笔记——一切都是对象
date:   2017-12-27 17:38:12
author:  'zhangtao'
header-img: 'img/post-bg-2015.jpg'
catalog:   false
tags:
-Java编程思想

---



## 用引用操纵对象

“引用”(reference)，遥控器（引用）操纵电视机（对象）。同时有一个引用，并不需要有一个对象与它关联。操作一个词或句子，则可以创建一个String引用：

```java
String s;
```

但这里创建的只是引用，并不是对象。如果向s发送消息，则会发生运行时错误，因为s并没有和任何对象关联。正确的做法是创建一个引用的同时并且初始化。

```java
String s = "Java";
```

Java语言的一个特性：字符串可以用带引号的文本初始化。通常，必须采用一种更为通用的方法进行初始化。

## 必须由你创建所有对象

一旦创建引用，就希望它与新的对象相关联，new：给我一个新对象。

```java
String s = new String("Java");
```

#### 存储到什么地方

五种可以存储数据的地方：  1.寄存器  处理器内部，速度最快，但寄存器数量极其有限，根据需求进行分配，不能直接控制。  2.堆栈  通用RAM（随机访问存储器），Java对象引用存储其中。Java系统必须十分清楚存储在堆栈中的所有项的生命周期，以便上下移动堆栈指针（下移，分配新内存；上移，释放内存）。  3.堆  通用的内存池（RAM区），存放所有Java对象，编译器不需要知道存储的数据在堆里存活多长时间。用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。  4.常量存储  常量值通常存放在程序代码内部。在嵌入式系统中，常量本身会和其他部分隔离开，可选择存放在ROM（只读存储器）。  5.非RAM存储  数据完全存活在程序之外，不受程序的任何控制——流对象（对象转化成字节流）和持久化对象（对象存放在磁盘上）

#### 特例：基本类型

基本类型，Java采用和C和C++相同的方法，不用new创建变量，而是创建一个并非是引用的“自动”变量，这个变量直接存储值，并置于堆栈。  Java要确定每种基本类型所占存储空间的大小，这种所占存储空间大小的不变性是Java程序比其他编程语言根据移植性的原因之一。


基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。

```java
char c = 'X';
Character ch = new Character(c);
```

也可以用：

```java
Character c= new Character('X');
```

Java SE5的自动包装功能将自动的将基本类型转换成包装器类型。

```java
Character ch = 'X';
```

并可以反向转换：

```java
char c = ch;
```

##### 高精度数字

BigInteger和BigDecimal，大体上属于包装器类，但没有对对应的基本类型，必须以方法调用方式替代运算符方式来实现，所以运算速度会比较慢。  BigInteger支持任意精度的整数，可以表示任何大小的整数，而不会丢失任何信息。  BigDecimal支持任意精度的定点数。

#### 数组

在c和c++中使用数组是很危险的，因为c和c++中的数组就是内存块。如果一个程序要访问自身以外内存块的数组，就会出现难以预料的后果。  Java的主要目标之一是安全性，c和c++的问题不会出现在Java中。Java确保数组被初始化，而且不能在它的范围之外被访问。这种范围检查是以每个数组上少量的内存开销以及运行时的下标检查为代价，由此换来的是安全性和效率的提高。

## 永远不需要销毁对象

#### 作用域

作用域（scope）决定了在其内定义的变量名的可见性和生命周期。在c、c++和Java中，作用域由花括号的位置决定。  缩排格式使得Java代码更易阅读，java是一种自由格式语言（free-form），所以空格、制表符、换行都不会影响代码运行结果。

```java
{
int i = 12;
    {
        int i = 96;
    }
}
```

c和c++中将一个较大作用域的变量“隐藏”起来，在Java是不允许的，Java设计者认为这样会造成程序混乱。

#### 对象的作用域

Java对象不具备和基本类型一样的生命周期，它可以存活于作用域之外。

```java
{
    String s = new String("Java");
}//end of scope
```

引用s在作用域终点就消失了，然而s指向的String对象仍继续占据着内存空间。  Java有一个垃圾回收器，用来监视用new创建的所有对象，并辨别那些不会再被引用的对象。随后，释放这些对象的内存空间，以便供其他新的对象使用。

## 创建新的数据类型：类

一旦定义一个类，可以在类中设置两个类型的元素：字段（数据成员）和方法（成员函数）。字段可以是任意类型的对象，也可以是基本类型。如果字段是对某个对象的引用，那么必须初始化该引用。

#### 基本成员默认值

若类的某个成员是基本类型，即使没有初始化，java也会确保它获得一个默认值。


## 创建一个Java程序

#### 名字可见性

所有文件都存活于自己的名字空间内，而每一个文件内的每个类都有唯一的标识符。  如果在使用某个特定名字的类，但其定义缺不值一份。在写程序时，在构建过程中，你想将某个新类添加到类库中，但却与已有的某个类名冲突。可以使用import来准确的告诉编译器你想要那个类。import指示编译器倒入一个包，也就是一个类库。

#### static关键字

有两种情形使用new是无法解决的：  1.只想为某特定域来分配单一存储空间，而不去考虑究竟要创建多少对象，甚至根本不创建任何对象。  2.希望某个方法不与包含他的类的任何对象关联在一起。  也就是说，即使没有创建对象，也能够调用这个方法。

当声明一个static时，就意味着这个域或者方法不会与包含他的那个类的任何对象实例关联在一起。所以，即使从未创建某个类的任何对象，还可以调用其static方法或访问其static域。

```java
class Incrementable{
    static void increment(){
    }
}
```

Incrementable的increment方法可以采用典型方法，通过对象来调用increment()，但是会警告：

```java
Incrementable sf = new Incrementable();
sf.increment();
```

或者通过类直接调用：

```java
Incrementable.increment();
```

尽管当static作用于某个字段时，肯定会改变数据创建方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象有一个存储空间），但如果static作用于方法，差别却没有那么大。static方法的一个重要用法就是不在创建任何对象的前提下调用它。

#### 注释文档

javadoc用于提取注释的工具，他是JDK安装的一部分。它采用了Java编辑器的某些技术，查找程序内的特殊注释标签。它不仅解析有这些标签标记的信息，也将毗邻注释的雷鸣或方法名抽取出来。javadoc输出是一个HTML文件，可以用Web浏览器查看。

##### 语法

所有javadoc命令都只能在“/ **”注释中出现，以“* /”结束。使用javadoc的方式主要有两种：嵌入HTML，或者使用“文档标签”。  共有三种类型的注释文档，分别对应于注释位置后面的三种元素：类、方法和域。  javadoc只能为public和protected成员进行文档注释。private和包内可访问成员的注释会被忽略掉。  1.嵌入HTML  不要嵌入HTML使用标题，因为javadoc会自己插入标题，可能同它们发生冲突。

```java
/**
 * <pre>javadoc Test<pre/>
 * You can <em>even<em/> insert a list.
 * <ul>
 * <li>Item 1<li/>
 * <li>Item 2<li/>
 * <li>Item 3<li/>
 * <ul/>
 */
```

2.一些标签实例  @see 引用其他类，在生成文档中加入一个参见条目的超链接，但javadoc不会检查你的超连接是否有效

{@link } 和@see相似，只是用于行内，使用“label”做为超链接文本

{@docRoot} 该标签产生到文档根目录的绝对路径，用于文档树页面的显示超连接

{@inheritDoc}该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接

@version 版本说明的重要信息

@author 作者信息

@since 指定程序代码最早使用的版本

@param 方法的参数列表，可延续数行

@return 方法返回值

@throws 异常，某个方法调用失败而抛出的对象

@deprecated 指出一些旧特性已由改进的新特性取代，在java se5中，该标签已经被@Deprecated注解所替代。

