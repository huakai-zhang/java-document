#### 分库分表之后，id 主键如何处理？

1. 基于数据库

   数据库id自增（不能处理高并发）
   设置数据库 sequence 或者表自增步长

2. UUID
3. 获取系统当前时间
4. snowflake 算法（ 64 位的 long 型的 id，1 个 bit 是不用的，用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号 ）

#### MySQL中myisam与innodb的区别？

MyISAM 不支持事务，表锁，存储总行数，一个表三个文件（索引文件，表结构文件，数据文件）， 采用非聚集索引 

innodb 支持事务，行锁及外键约束，不存储总行数，表空间， 主键索引采用聚集索引（索引的数据域存储数据文件本身） 

#### MySQL INT和CHAR隐式类型转换需要注意什么？

1. 当查询字段是INT类型，如果查询条件为CHAR，将查询条件转换为INT，如果是字符串前导都是数字，将截取前导数字用来比较，如果没有前导数字，则转换为0。

2. 当查询字段是CHAR/VARCHAR类型，如果查询条件为INT，将查询字段转换为INT再进行比较，可能会造成全表扫描。

#### MySQL 如何高效率随机获取N条数据？

```mysql
SELECT
		ROUND(
			RAND() * (
				SELECT
					MAX(customer_id)
				FROM
					customer
			)
		) AS id
```

#### MySQL的索引类型，并分别简述一下各自的场景？

**普通索引：**没有任何限制条件的索引，该索引可以在任何数据类型中创建。

**唯一索引：**使用UNIQUE参数可以设置唯一索引。创建该索引时，索引列的值必须唯一，但允许有空值。通过唯一索引，用户可以快速地定位某条记录，主键索引是一种特殊的唯一索引。

**全文索引：**仅可用于 MyISAM 表，针对较大的数据，生成全文索引耗时耗空间。

**空间索引：**只能建立在空间数据类型上。这样可以提高系统获取空间数据类型的效率。仅可用于 MyISAM 表，索引的字段不能为空值。使用SPATIAL参数可以设置索引为空间索引。

**单列索引：**只对应一个字段的索引。

**多列索引：**在表的多个字段上创建一个索引。该索引指向创建时对应的多个字段，用户可以通过这几个字段进行查询，想使用该索引，用户必须使用这些字段中的一个字段。(EXPLAIN 查询顺序 row)

#### MySQL查询字段区不区分大小写？

 不区分 

MySQL默认的字符检索策略：`utf8_general_ci`，表示不区分大小写。可以使用`utf8_general_cs`，表示区分大小写，也可以使用`utf8_bin`，表示二进制比较

查询的字段前面加上binary关键字 

#### MySQL innodb的事务与日志的实现方式

　　1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

 **有多少种日志**

- 错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
- 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
- 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。
- 二进制日志：记录对数据库执行更改的所有操作。
- 中继日志：中继日志也是二进制日志，用来给slave 库恢复
- 事务日志：重做日志redo和回滚日志undo

**事务是如何通过日志来实现的，说得越深入越好**

事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号;

当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；

当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过`innodb_flush_log_at_trx_commit`来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”

#### MySQL binlog的几种日志录入格式以及区别

``Statement`` 每一条会修改数据的sql都会记录在binlog中

``Row`` 不记录sql语句上下文相关信息，仅保存哪条记录被修改

``Mixedlevel`` 以上两种level的混合使用

#### 来谈谈SQL中的in与not in、exists与not exists的区别

in是把外表和内表作hash连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。

子查询表大的用exists，子查询表小的用in；

请尽量不要使用not in(它会调用子查询)，而尽量使用not exists（它会调用关联子查询）